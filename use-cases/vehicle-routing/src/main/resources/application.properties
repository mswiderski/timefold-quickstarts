########################
# General properties
########################
# Enable CORS for runQuickstartsFromSource.sh
quarkus.http.cors=true
quarkus.http.cors.origins=/http://localhost:.*/

# Allow all origins in dev-mode
%dev.quarkus.http.cors.origins=/.*/

# OpenAPI and swagger ui configuration
quarkus.swagger-ui.always-include=true
quarkus.swagger-ui.title=Vehicle-routing - Timefold
quarkus.smallrye-openapi.store-schema-directory=target/openapi-schema
mp.openapi.extensions.smallrye.info.title=Vehicle-routing service
mp.openapi.extensions.smallrye.info.version=${model.api.version}
mp.openapi.extensions.smallrye.info.description=Vehicle Routing with time windows and capacity planning. Generate optimal route plan of a vehicle fleet with limited vehicle capacity and time windows
mp.openapi.extensions.smallrye.info.contact.email=info@timefold.ai
mp.openapi.extensions.smallrye.info.contact.name=Timefold BV
mp.openapi.extensions.smallrye.info.contact.url=https://timefold.ai

# timefold application info
timefold.application.name=${quarkus.application.name}
timefold.application.version=${quarkus.application.version}
timefold.application.build-timestamp=@maven.build.timestamp@

# logging configuration
quarkus.log.console.format=%d{HH:mm:ss.SSS} %5p [%t] %m%n
# Workaround on white-background console for https://github.com/quarkusio/quarkus/issues/33541
quarkus.log.console.darken=1

# JSON serialization configuration
quarkus.jackson.fail-on-unknown-properties=true
ai.timefold.orbit.models.validation.enable=false
# development profile settings
%dev.ai.timefold.orbit.termination.spent-limit=PT30S


# model info
quarkus.application.name=vehicle-routing
timefold.model.maturity-level=Example

timefold.model.features[0]=Vehicle Capacity
timefold.model.features[1]=Service Finished After Max End Time
timefold.model.features[2]=Minimize Travel Time

timefold.rest.schedule.summary=Request a vehicle routing to be solved, unique identifier is returned that can be used to get the route plan once solved
timefold.rest.getSchedules.summary=List all route plans that are registered in the service (that are to be solved, in progress or solved), only returning its status
timefold.rest.getSchedule.summary=Get a route plan with the given identifier. It's the best schedule so far as the solver might still be running.
timefold.rest.getScheduleStatus.summary=Get an route plan status with the given identifier
timefold.rest.terminateSchedule.summary=Terminate and return an route plan with the given identifier

########################
# Timefold properties
########################


ai.timefold.orbit.termination.spent-limit=PT30M
ai.timefold.orbit.termination.maximum-spent-limit=PT60M
ai.timefold.orbit.termination.unimproved-spent-limit=PT5M
ai.timefold.orbit.termination.maximum-unimproved-spent-limit=PT5M

quarkus.timefold.solver.constraint-stream-impl-type=BAVET

# To change how many solvers to run in parallel
# timefold.solver-manager.parallel-solver-count=4

# To run increase CPU cores usage per solver
# quarkus.timefold.solver.move-thread-count=2

# Temporary comment this out to detect bugs in your code (lowers performance)
# quarkus.timefold.solver.environment-mode=FULL_ASSERT

# Temporary comment this out to return a feasible solution as soon as possible
# quarkus.timefold.solver.termination.best-score-limit=0hard/*soft


# To see what Timefold is doing, turn on DEBUG or TRACE logging.
quarkus.log.category."ai.timefold.solver".level=INFO
%test.quarkus.log.category."ai.timefold.solver".level=INFO
%prod.quarkus.log.category."ai.timefold.solver".level=INFO

# XML file for power tweaking, defaults to solverConfig.xml (directly under src/main/resources)
#quarkus.timefold.solver-config-xml=org/acme/vehiclerouting/solver/vehicleRoutingSolverConfig.xml

########################
# Map Service Client configuration
########################

# Map service Endpoint
ai.timefold.orbit.map-service.url=http://localhost:8180
quarkus.rest-client.map-service.url=${ai.timefold.orbit.map-service.url}
ai.timefold.orbit.map-service.use-remote=false

%dev.ai.timefold.orbit.map-service.enable-fallback=true

# Distance matrix calculation potentially takes a long time, avoid timeouts
ai.timefold.orbit.map-service.read-timeout=3600000
quarkus.rest-client.map-service.read-timeout=${ai.timefold.orbit.map-service.read-timeout}

########################
# Test overrides
########################
# Effectively disable this termination in favor of the best-score-limit
%test.ai.timefold.orbit.termination.spent-limit=PT10S
%test.quarkus.timefold.solver.termination.best-score-limit=0hard/*soft

########################
# Container configuration
########################

%container.quarkus.container-image.group=timefoldai
%container.quarkus.container-image.name=vehicle-routing
%container.quarkus.jib.base-jvm-image=eclipse-temurin:21-jre-alpine
%container.quarkus.jib.jvm-additional-arguments=-Djava.net.useSystemProxies\=true

########################
# Storage configuration
########################

# Storage based on file system
%fs-storage.ai.timefold.storage.ttl=P5D
%fs-storage.ai.timefold.storage.path=target/solver-data
%fs-storage.quarkus.container-image.name=orbit-vehicle-routing
%fs-storage.ai.timefold.orbit.map-service.use-remote=true

# Storage based on AWS S3
%s3-storage.ai.timefold.storage.bucket=vehicle-routing
%s3-storage.quarkus.container-image.name=orbit-vehicle-routing-s3
%s3-storage.ai.timefold.orbit.map-service.use-remote=true

#Storage based on Google Cloud Storage
%gcs-storage.ai.timefold.storage.bucket=vehicle-routing
%gcs-storage.quarkus.google.cloud.project-id=orbit-timefold-dev
%gcs-storage.quarkus.container-image.name=orbit-vehicle-routing-gcs
%gcs-storage.ai.timefold.orbit.map-service.use-remote=true

#Storage based on Azure BlobStore Storage
%azure-storage.ai.timefold.storage.bucket=vehicle-routing
%azure-storage.quarkus.container-image.name=orbit-vehicle-routing-azure
%azure-storage.ai.timefold.orbit.map-service.use-remote=true